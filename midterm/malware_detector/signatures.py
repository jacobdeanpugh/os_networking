import hashlib
import os
import requests
import sqlite3
import zipfile
import pandas as pd
import csv
from io import StringIO
from .config import config
from .logger import logger

class Signature_Manager():

    def __init__(self):
        self.malware_bazzar_db_url = config["signatures"]["malware_bazzar_db_url"]
        self.local_db_path = os.path.join(os.path.dirname(__file__), config["signatures"]["local_db"])

    def generate_file_sha256(self, file):
        m = hashlib.sha256()
        try:
            m.update(file)
            return m.hexdigest()
        except Exception as e:
            logger.error(f"Error Occured Hashing File: {e}")
            raise Exception(e)

    def get_file_bytes(self, file_path):
        try:
            with open(file_path, 'rb') as f:
                return f.read()
        except Exception as e:
            logger.error(f"Error Occured Getting File Bytes: {e}")
            raise Exception(e)

    def fetch_malware_bazzar_csv(self):
        # Create Staging Area
        stage_path = os.path.join(os.path.dirname(__file__), "staging")
        os.makedirs(stage_path, exist_ok=True)
        zip_path = os.path.join(stage_path, "bazzar.zip")

        logger.info("Making Request For Malware Bazzare CSV")

        # Download ZIP file
        response = requests.get(self.malware_bazzar_db_url, stream=True)

        try:
            response.raise_for_status()
        except Exception as e:
            logger.critical("Malware Bazzar CSV not accessable: ", e)
            raise Exception(e)

        with open(zip_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)

        logger.info("Successfully Download Malware Bazzar CSV")
        
        try:
            logger.info("Attempting to UNZIP file")
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(stage_path)
        except Exception as e:
            logger.critical("Error Occurred Unzipping file")
            raise Exception(e)
        
        logger.info("Successfully Unzipped File")

        os.remove(zip_path)

        return stage_path

    def db_refresh_malware_bazzar_csv(self, stage_path):
        try:
            logger.info("Cleaning CSV")

            csv_file_path = os.path.join(stage_path, "full.csv")

            with open(csv_file_path, "r") as infile:
                lines = infile.readlines()

            # Remove meta-data header
            lines = lines[8:]

            # Remove first # from column header line
            lines[0] = lines[0][2:]

            # Convert strings into file type
            csv_text = "\n".join(lines)

            df = pd.read_csv(StringIO(csv_text), quotechar='"', skipinitialspace=True)

            logger.info("Attempting to load CSV into local DB")

            con = sqlite3.connect(self.local_db_path)
            df.to_sql("malware_signatures", con, if_exists="replace", index=False)
            con.close()
        except Exception as e:
            logger.error(f"Error loading CSV into local DB: {e}")
            raise Exception(e)
        
        logger.info("Successfuly loaded CSV into local DB")

    def clear_staging(self, stage_path):
        try:
            logger.info(f"Attempting clean up on directory: {stage_path}")
            if not os.path.exists(stage_path):
                return
            
            directory_items = os.listdir(stage_path)

            for item in directory_items:
                item_path = os.path.join(stage_path, item)
                os.remove(item_path)

            os.rmdir(stage_path)
            
        except Exception as e:
            logger.error(f"Error occured while clearing staging directory: {e}")
            raise Exception(e)
        
        logger.info(f"Successfully cleared staging directory")

    def initialize_local_db(self):
        logger.info("Attempting to initalize local DB")
        try:
            stage_path = self.fetch_malware_bazzar_csv()
            self.db_refresh_malware_bazzar_csv(stage_path)
            self.clear_staging(stage_path)
        except Exception as e:
            logger.error(f"An error occurred initializing local DB:")
            return

        logger.info("Successfully Initialized local DB")

    # TODO: Update to cache signatures into a sqllite DB
    def query_file_hash(self, file_hash):
        headers = {
            "Auth-Key": self.key
        }
        data = {
            "query": "get_info",
            "hash" : file_hash
        }

        response = requests.post(self.endpoint, headers=headers, data=data)
        try:
            response.raise_for_status()
        except Exception as e:
            logger.error(f"Error Occured Querying File Hash: {e}")
            raise Exception(e)
        return response
    
    def is_file_signature_malware(self, file_path):
        try:
            file_bytes = self.get_file_bytes(file_path)
            file_sha256 = self.generate_file_sha256(file_bytes)
            query_response = self.query_file_hash(file_sha256).json()

            if query_response.get("file_name", None) is None:
                logger.info(f"File signature not found in Malware Database: {file_path}")
                return False
            
        except Exception as e:
            logger.error("File Signature Query Failed")
            return None
        
        logger.info(f"Malware Detected! {file_path}")
        return True

    # Set depth to 0 to scan one directory
    def recursively_scan_directory(self, dir_path, depth=-1):
        # Seperate file and directory paths
        directory_files = []
        nested_directories = []
        for item in os.listdir(dir_path):
            full_path = os.path.join(dir_path, item)

            if os.path.isdir(full_path):
                nested_directories.append(full_path)
            else:
                directory_files.append(full_path)

        results = {}

        for file in directory_files:
            results[file] = self.is_file_signature_malware(file)

        # Handle depth limiter: if depth < 0 will function will continue until last subdirectory is found
        if depth == 0:
            return results
        depth -= 1

        for dir in nested_directories:
            results.update(self.recursively_scan_directory(dir, depth))

        return results

