import hashlib
import os
import requests
import sqlite3
import zipfile
import pandas as pd
from io import StringIO
from datetime import datetime
from .config import config
from .logger import logger

class Signature_Manager():

    def __init__(self):
        self.malware_bazzar_db_url = config["signatures"]["malware_bazzar_db_url"]
        self.local_db_path = os.path.join(os.path.dirname(__file__), config["signatures"]["local_db"])
        self.local_db_con = con = sqlite3.connect(self.local_db_path)

    def generate_file_sha256(self, file):
        m = hashlib.sha256()
        try:
            m.update(file)
            return m.hexdigest()
        except Exception as e:
            logger.error(f"Error Occured Hashing File: {e}")
            raise Exception(e)

    def get_file_bytes(self, file_path):
        try:
            with open(file_path, 'rb') as f:
                return f.read()
        except Exception as e:
            logger.error(f"Error Occured Getting File Bytes: {e}")
            raise Exception(e)

    def fetch_malware_bazzar_csv(self):
        # Create Staging Area
        stage_path = os.path.join(os.path.dirname(__file__), "staging")
        os.makedirs(stage_path, exist_ok=True)
        zip_path = os.path.join(stage_path, "bazzar.zip")

        logger.info("Making Request For Malware Bazzare CSV")

        # Download ZIP file
        response = requests.get(self.malware_bazzar_db_url, stream=True)

        try:
            response.raise_for_status()
        except Exception as e:
            logger.critical("Malware Bazzar CSV not accessable: ", e)
            raise Exception(e)

        with open(zip_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)

        logger.info("Successfully Download Malware Bazzar CSV")
        
        try:
            logger.info("Attempting to UNZIP file")
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(stage_path)
        except Exception as e:
            logger.critical("Error Occurred Unzipping file")
            raise Exception(e)
        
        logger.info("Successfully Unzipped File")

        os.remove(zip_path)

        return stage_path

    def db_refresh_malware_bazzar_csv(self, stage_path):
        try:
            logger.info("Cleaning CSV")

            csv_file_path = os.path.join(stage_path, "full.csv")

            with open(csv_file_path, "r", encoding="utf-8-sig") as infile:
                lines = infile.readlines()

            # Remove meta-data header
            lines = lines[8:]

            # Remove first # from column header line
            lines[0] = lines[0][2:]

            # Convert strings into file type
            csv_text = "\n".join(lines)

            csv_text = csv_text.encode("utf-8", errors="ignore").decode("utf-8")

            df = pd.read_csv(StringIO(csv_text), quotechar='"', skipinitialspace=True, encoding="UTF-8")

            df = df[["sha256_hash", "file_name"]]

            # **Manually add the last_updated column before inserting**
            df["last_updated"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            # Create table (if not exists)
            self.local_db_con.execute("""
                CREATE TABLE IF NOT EXISTS malware_signatures (
                    sha256_hash TEXT PRIMARY KEY,
                    file_name TEXT,
                    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)


            logger.info("Attempting to load CSV into local DB")

            df.to_sql("malware_signatures", self.local_db_con, if_exists="replace", index=False)

            # Create index for faster lookups
            self.local_db_con.execute("CREATE INDEX IF NOT EXISTS idx_files_sha256 ON malware_signatures(sha256_hash);")

            self.local_db_con.commit()


        except Exception as e:
            logger.error(f"Error loading CSV into local DB: {e}")
            raise Exception(e)
        
        logger.info("Successfuly loaded CSV into local DB")

    def clear_staging(self, stage_path):
        try:
            logger.info(f"Attempting clean up on directory: {stage_path}")
            if not os.path.exists(stage_path):
                return
            
            directory_items = os.listdir(stage_path)

            for item in directory_items:
                item_path = os.path.join(stage_path, item)
                os.remove(item_path)

            os.rmdir(stage_path)

        except Exception as e:
            logger.error(f"Error occured while clearing staging directory: {e}")
            raise Exception(e)
        
        logger.info(f"Successfully cleared staging directory")

    def initialize_local_db(self):
        logger.info("Attempting to initalize local DB")
        try:
            stage_path = self.fetch_malware_bazzar_csv()
            self.db_refresh_malware_bazzar_csv(stage_path)
            self.clear_staging(stage_path)
        except Exception as e:
            logger.error(f"An error occurred initializing local DB:")
            return

        logger.info("Successfully Initialized local DB")

    def query_file_hash(self, file_hash):
        query = f"""
                SELECT sha256_hash FROM malware_signatures WHERE sha256_hash = "{file_hash}"
        """

        cursor = self.local_db_con.cursor()

        cursor.execute(query)
        response = cursor.fetchall()
        return response
    
    def is_file_signature_malware(self, file_path=None, file_bytes=None):
        try:
            if file_bytes is None and file_path is not None:
                file_bytes = self.get_file_bytes(file_path)
            file_sha256 = self.generate_file_sha256(file_bytes)
            query_response = self.query_file_hash(file_sha256)
            if len(query_response) < 1:
                logger.debug(f"File Not Found In Malware DB: {file_path}")
                return False
            
        except Exception as e:
            logger.error(f"File Signature Query Failed: {e}")
            return None
        
        logger.critical(f"Malware Detected! {file_path}")
        return True
    
    def recursively_scan_directory(self, dir_path, depth=-1):
        # Seperate file and directory paths
        directory_files = []
        nested_directories = []
        for item in os.listdir(dir_path):
            full_path = os.path.join(dir_path, item)

            if os.path.isdir(full_path):
                nested_directories.append(full_path)
            else:
                directory_files.append(full_path)

        results = {}

        for file in directory_files:
            results[file] = self.is_file_signature_malware(file)

        # Handle depth limiter: if depth < 0 will function will continue until last subdirectory is found
        if depth == 0:
            return results
        depth -= 1

        for dir in nested_directories:
            results.update(self.recursively_scan_directory(dir, depth))

        return results

    def scan_zip(self, zip_path, password=None):
        results = {}
        try:
            with zipfile.ZipFile(zip_path, 'r') as zipf:
                for file_name in zipf.namelist():
                    if file_name.endswith("/"):
                        continue
                    try:
                        with zipf.open(file_name, pwd=password.encode() if password else None) as file:
                            bytes = file.read()
                            file_path = os.path. join(zip_path, file_name)
                            results[file_name] = self.is_file_signature_malware(file_path=file_path, file_bytes=bytes)
                    except Exception as e:
                        logger.error(f"Error Occured Hashing file {file_name}: {e}")
                        raise Exception(e)
        except Exception as e:
            logger.error(f"Error occured opening zip {zip_path}: {e}")
            raise Exception(e)
        return results

