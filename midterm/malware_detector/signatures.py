import hashlib
import os
import requests
import sqlite3
import zipfile
from .config import config
from .logger import logger

class Signature_Manager():

    def __init__(self):
        self.malware_bazzar_db_url = config["signatures"]["malware_bazzar_db_url"]


    def generate_file_sha256(self, file):
        m = hashlib.sha256()
        try:
            m.update(file)
            return m.hexdigest()
        except Exception as e:
            logger.error(f"Error Occured Hashing File: {e}")
            raise Exception(e)


    def get_file_bytes(self, file_path):
        try:
            with open(file_path, 'rb') as f:
                return f.read()
        except Exception as e:
            logger.error(f"Error Occured Getting File Bytes: {e}")
            raise Exception(e)
        
    def fetch_malware_bazzar_db(self):
        # Create Staging Area
        stage_path = os.path.join(os.path.dirname(__file__), "staging")
        os.makedirs(stage_path, exist_ok=True)
        zip_path = os.path.join(stage_path, "bazzar.zip")

        logger.info("Making Request For Malware Bazzare CSV")

        # Download ZIP file
        response = requests.get(self.malware_bazzar_db_url, stream=True)

        try:
            response.raise_for_status()
        except Exception as e:
            logger.critical("Malware Bazzar CSV not accessable: ", e)
            raise Exception(e)

        with open(zip_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)

        logger.info("Successfully Download Malware Bazzar CSV")
        
        try:
            logger.info("Attempting to UNZIP file")
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(stage_path)
        except Exception as e:
            logger.critical("Error Occurred Unzipping file")
            raise Exception(e)
        
        logger.info("Successfully Unzipped File")

        os.remove(zip_path)



    # TODO: Update to cache signatures into a sqllite DB
    def query_file_hash(self, file_hash):
        headers = {
            "Auth-Key": self.key
        }
        data = {
            "query": "get_info",
            "hash" : file_hash
        }

        response = requests.post(self.endpoint, headers=headers, data=data)
        try:
            response.raise_for_status()
        except Exception as e:
            logger.error(f"Error Occured Querying File Hash: {e}")
            raise Exception(e)
        return response
    
    
    def is_file_signature_malware(self, file_path):
        try:
            file_bytes = self.get_file_bytes(file_path)
            file_sha256 = self.generate_file_sha256(file_bytes)
            query_response = self.query_file_hash(file_sha256).json()

            if query_response.get("file_name", None) is None:
                logger.info(f"File signature not found in Malware Database: {file_path}")
                return False
            
        except Exception as e:
            logger.error("File Signature Query Failed")
            return None
        
        logger.info(f"Malware Detected! {file_path}")
        return True

    # Set depth to 0 to scan one directory
    def recursively_scan_directory(self, dir_path, depth=-1):
        # Seperate file and directory paths
        directory_files = []
        nested_directories = []
        for item in os.listdir(dir_path):
            full_path = os.path.join(dir_path, item)

            if os.path.isdir(full_path):
                nested_directories.append(full_path)
            else:
                directory_files.append(full_path)

        results = {}

        for file in directory_files:
            results[file] = self.is_file_signature_malware(file)

        # Handle depth limiter: if depth < 0 will function will continue until last subdirectory is found
        if depth == 0:
            return results
        depth -= 1

        for dir in nested_directories:
            results.update(self.recursively_scan_directory(dir, depth))

        return results

