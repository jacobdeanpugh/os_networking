import hashlib
import os
import requests
from .config import config
from .logger import logger

class Signature_Manager():

    def __init__(self):
        self.key = config["signatures"]['malware_bazzar_api_key']
        self.endpoint = config["signatures"]['malware_bazzar_endpoint']


    def generate_file_sha256(self, file):
        m = hashlib.sha256()
        try:
            m.update(file)
            return m.hexdigest()
        except Exception as e:
            logger.error(f"Error Occured Hashing File: {e}")
            raise Exception(e)


    def get_file_bytes(self, file_path):
        try:
            with open(file_path, 'rb') as f:
                return f.read()
        except Exception as e:
            logger.error(f"Error Occured Getting File Bytes: {e}")
            raise Exception(e)

    # TODO: Update to cache signatures into a sqllite DB
    def query_file_hash(self, file_hash):
        headers = {
            "Auth-Key": self.key
        }
        data = {
            "query": "get_info",
            "hash" : file_hash
        }

        response = requests.post(self.endpoint, headers=headers, data=data)
        try:
            response.raise_for_status()
        except Exception as e:
            logger.error(f"Error Occured Querying File Hash: {e}")
            raise Exception(e)
        return response
    
    
    def is_file_signature_malware(self, file_path):
        try:
            file_bytes = self.get_file_bytes(file_path)
            file_sha256 = self.generate_file_sha256(file_bytes)
            query_response = self.query_file_hash(file_sha256).json()

            if query_response.get("file_name", None) is None:
                logger.info(f"File signature not found in Malware Database: {file_path}")
                return False
            
        except Exception as e:
            logger.error("File Signature Query Failed")
            return None
        
        logger.info(f"Malware Detected! {file_path}")
        return True

    # Set depth to 0 to scan one directory
    def recursively_scan_directory(self, dir_path, depth=-1):
        # Seperate file and directory paths
        directory_files = []
        nested_directories = []
        for item in os.listdir(dir_path):
            full_path = os.path.join(dir_path, item)

            if os.path.isdir(full_path):
                nested_directories.append(full_path)
            else:
                directory_files.append(full_path)

        results = {}

        for file in directory_files:
            results[file] = self.is_file_signature_malware(file)

        # Handle depth limiter: if depth < 0 will function will continue until last subdirectory is found
        if depth == 0:
            return results
        depth -= 1

        for dir in nested_directories:
            results.update(self.recursively_scan_directory(dir, depth))

        return results

